#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "bme280.h"
#include "common.h"
#include "print.h"

#define SDA_PIN GPIO_NUM_18
#define SCL_PIN GPIO_NUM_19

#define TAG_BME280 "BME280"
#define SAMPLE_COUNT  UINT8_C(5)//0)

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1
#define I2C_MASTER_TX_BUF_DISABLE 0 /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE 0 /*!< I2C master doesn't need buffer */

uint8_t dev_addr = 0;

static int8_t get_temperature(uint32_t period, struct bme280_dev *dev);

void i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 1000000
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);
	i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, I2C_MASTER_RX_BUF_DISABLE, I2C_MASTER_TX_BUF_DISABLE, 0);
}

void bme280_error_codes_print_result(const char api_name[], int8_t rslt)
{
    if (rslt != BME280_OK)
    {
        printf("%s\t", api_name);

        switch (rslt)
        {
            case BME280_E_NULL_PTR:
                printf("Error [%d] : Null pointer error.", rslt);
                printf(
                    "It occurs when the user tries to assign value (not address) to a pointer, which has been initialized to NULL.\r\n");
                break;

            case BME280_E_COMM_FAIL:
                printf("Error [%d] : Communication failure error.", rslt);
                printf(
                    "It occurs due to read/write operation failure and also due to power failure during communication\r\n");
                break;

            case BME280_E_DEV_NOT_FOUND:
                printf("Error [%d] : Device not found error. It occurs when the device chip id is incorrectly read\r\n",
                       rslt);
                break;

            case BME280_E_INVALID_LEN:
                printf("Error [%d] : Invalid length error. It occurs when write is done with invalid length\r\n", rslt);
                break;

            default:
                printf("Error [%d] : Unknown error code\r\n", rslt);
                break;
        }
    }
}

int8_t BME280_I2C_bus_write(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len,
        void *intf_ptr)
{
	uint8_t dev_addr = *(uint8_t*)intf_ptr;
	int32_t iError = BME280_INTF_RET_SUCCESS;

	esp_err_t espRc;
	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);

	i2c_master_write_byte(cmd, reg_addr, true);
	i2c_master_write(cmd, reg_data, len, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK)
	{
		iError = BME280_INTF_RET_SUCCESS;
	}
	else
	{
		iError = BME280_E_COMM_FAIL;
	}
	i2c_cmd_link_delete(cmd);

	return (int8_t)iError;
}

int8_t BME280_I2C_bus_read(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr)
{
	uint8_t dev_addr = *(uint8_t*)intf_ptr;
	ESP_LOGI(TAG_BME280, "Read Dev %x Reg %x len %ld", dev_addr, reg_addr, len);
	int32_t iError = BME280_INTF_RET_SUCCESS;
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, reg_addr, true);

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_READ, true);

	if (len > 1) {
		i2c_master_read(cmd, reg_data, len-1, I2C_MASTER_ACK);
	}
	i2c_master_read_byte(cmd, reg_data+len-1, I2C_MASTER_NACK);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK)
	{
		iError = BME280_INTF_RET_SUCCESS;
		print_buffer(reg_data, len, "");
	}
	else
	{
		iError = BME280_E_COMM_FAIL;
	}

	i2c_cmd_link_delete(cmd);

	return (int8_t)iError;
}

void BME280_delay_usec(uint32_t usec, void *intf_ptr)
{
	vTaskDelay(usec/1000/portTICK_PERIOD_MS);
}

void bme280_reader_task(void *ignore)
{
	i2c_master_init();
	dev_addr = BME280_I2C_ADDR_PRIM;
	struct bme280_dev dev = {
		.write = BME280_I2C_bus_write,
		.read = BME280_I2C_bus_read,
		.intf = BME280_I2C_INTF,
		.delay_us = BME280_delay_usec,
		.intf_ptr = &dev_addr,
	};

	int32_t rslt;
	uint32_t period = 0;
    struct bme280_settings settings;

	rslt = bme280_init(&dev);
	bme280_error_codes_print_result("bme280_init", rslt);

	/* Always read the current settings before writing, especially when all the configuration is not modified */
	rslt = bme280_get_sensor_settings(&settings, &dev);
	bme280_error_codes_print_result("bme280_get_sensor_settings", rslt);

	/* Configuring the over-sampling rate, filter coefficient and standby time */
	/* Overwrite the desired settings */
	settings.filter = BME280_FILTER_COEFF_2;

	/* Over-sampling rate for humidity, temperature and pressure */
	settings.osr_h = BME280_OVERSAMPLING_1X;
	settings.osr_p = BME280_OVERSAMPLING_1X;
	settings.osr_t = BME280_OVERSAMPLING_1X;

	/* Setting the standby time */
	settings.standby_time = BME280_STANDBY_TIME_0_5_MS;

	rslt = bme280_set_sensor_settings(BME280_SEL_ALL_SETTINGS, &settings, &dev);
	bme280_error_codes_print_result("bme280_set_sensor_settings", rslt);

	/* Always set the power mode after setting the configuration */
	rslt = bme280_set_sensor_mode(BME280_POWERMODE_NORMAL, &dev);
	bme280_error_codes_print_result("bme280_set_power_mode", rslt);

	/* Calculate measurement time in microseconds */
	rslt = bme280_cal_meas_delay(&period, &settings);
	bme280_error_codes_print_result("bme280_cal_meas_delay", rslt);

	printf("\nTemperature calculation (Data displayed are compensated values)\n");
	printf("Measurement time : %lu us\n\n", (long unsigned int)period);

	if (rslt == BME280_OK)
	{
		while(true)
		{
			vTaskDelay(4000/portTICK_PERIOD_MS);

			rslt = get_temperature(period, &dev);
			bme280_error_codes_print_result("get_temperature", rslt);

//			if (rslt == BME280_OK) {
//				ESP_LOGI(TAG_BME280, "%.2f degC / %.3f hPa / %.3f %%",
//					bme280_compensate_temperature_double(v_uncomp_temperature_s32),
//					bme280_compensate_pressure_double(v_uncomp_pressure_s32)/100, // Pa -> hPa
//					bme280_compensate_humidity_double(v_uncomp_humidity_s32));
//			} else {
//				ESP_LOGE(TAG_BME280, "measure error. code: %d", rslt);
//			}
		}
	}
	else
	{
		ESP_LOGE(TAG_BME280, "init or setting error. code: %ld", rslt);
	}

	vTaskDelete(NULL);
}

void app_main(void)
{
	bme280_reader_task(NULL);
	//xTaskCreate(&bme280_reader_task, "bme280_reader_task",  2048, NULL, 6, NULL);
}

double CtoF(double tempC)
{
	return (tempC * 9 / 5) + 32;
}

int8_t get_temperature(uint32_t period, struct bme280_dev *dev)
{
    int8_t rslt = BME280_E_NULL_PTR;
    int8_t idx = 0;
    uint8_t status_reg;
    struct bme280_data comp_data;

    while (idx < SAMPLE_COUNT)
    {
        rslt = bme280_get_regs(BME280_REG_STATUS, &status_reg, 1, dev);
        bme280_error_codes_print_result("bme280_get_regs", rslt);

        if (status_reg & BME280_STATUS_MEAS_DONE)
        {
            /* Measurement time delay given to read sample */
            dev->delay_us(period, dev->intf_ptr);

            /* Read compensated data */
            rslt = bme280_get_sensor_data(BME280_ALL, &comp_data, dev);
            bme280_error_codes_print_result("bme280_get_sensor_data", rslt);

#ifndef BME280_DOUBLE_ENABLE
            comp_data.temperature = comp_data.temperature / 100;
#endif

#ifdef BME280_DOUBLE_ENABLE
            printf("Temperature[%d]:   %lf deg C %lf deg F\n", idx, comp_data.temperature, CtoF(comp_data.temperature));
            printf("Humidity[%d]:   %lf %%RH\n", idx, comp_data.humidity);
            printf("Pressure[%d]:  %lf Pa\n", idx, comp_data.pressure);
#else
            printf("Temperature[%d]:   %ld deg C\n", idx, (long int)comp_data.temperature);
#endif
            idx++;
        }
    }

    return rslt;
}
